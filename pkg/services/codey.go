/*
Copyright 2024 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file contains the code for the Chat function, which uses the
// Google Cloud VertexAI Codey API to generate text responses to user prompts.
package genai

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"golang.org/x/oauth2/google"
	"google.golang.org/api/storage/v1"
)

const (
	accessTokenURL = "https://us-central1-aiplatform.googleapis.com/v1/projects/coffee-and-codey/locations/us-central1/publishers/google/models/codechat-bison:predict"
)

// accessToken is the access token used to authenticate requests to the Google Cloud Codechat API.
var accessToken string

func getAccessToken(ctx context.Context) {
	creds, err := google.FindDefaultCredentials(ctx, storage.CloudPlatformScope)
	if err != nil {
		log.Fatalf("Error finding default credentials: %v", err)
	}

	if creds.TokenSource == nil {
		log.Fatal("TokenSource is nil")
	}

	token, err := creds.TokenSource.Token()
	if err != nil {
		log.Fatalf("Error retrieving access token: %v", err)
	}

	accessToken = token.AccessToken
}

func makeHTTPRequest(jsonData []byte) ([]byte, error) {
	req, err := http.NewRequest("POST", accessTokenURL, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+accessToken)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error making request: %v", err)
	}
	defer resp.Body.Close()

	var responseBody bytes.Buffer
	_, err = responseBody.ReadFrom(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %v", err)
	}

	return responseBody.Bytes(), nil
}

func parseResponse(responseBody []byte) (string, error) {
	var responseMap map[string]interface{}
	if err := json.Unmarshal(responseBody, &responseMap); err != nil {
		return "", fmt.Errorf("error unmarshalling response body: %v", err)
	}

	// Detailed checks with helpful error messages
	predictions, ok := responseMap["predictions"].([]interface{})
	if !ok {
		return "", fmt.Errorf("predictions key not found in response")
	}
	if len(predictions) == 0 {
		return "", fmt.Errorf("predictions array is empty")
	}

	candidates, ok := predictions[0].(map[string]interface{})["candidates"].([]interface{})
	if !ok {
		return "", fmt.Errorf("candidates key not found or not an array")
	}
	if len(candidates) == 0 {
		return "", fmt.Errorf("candidates array is empty")
	}

	content, ok := candidates[0].(map[string]interface{})["content"].(string)
	if !ok {
		return "", fmt.Errorf("content key not found or not a string")
	}

	return content, nil
}

// The Chat function takes a prompt as input and returns a text response generated by the Google Cloud Codechat API.
func CodeyChat(prompt string) string {
	ctx := context.Background()
	getAccessToken(ctx)

	payload := map[string]interface{}{
		"instances": []map[string][]map[string]string{
			{
				"messages": []map[string]string{
					{"content": prompt},
				},
			},
		},
		"parameters": map[string]interface{}{
			// A measure of how often the model outputs a less likely token. The higher the temperature, the more random (and usually creative) the output. This, however, is not the same as “truthfulness”. For most factual use cases such as data extraction, and truthful Q&A, the temperature of 0 is best.
			"temperature":     0.5,
			"maxOutputTokens": 1024,
		},
	}

	jsonData, err := json.Marshal(payload)
	if err != nil {
		log.Fatalf("Error marshalling JSON: %v", err)
	}

	responseBody, err := makeHTTPRequest(jsonData)
	if err != nil {
		log.Fatalf("Error with HTTP request: %v", err)
	}

	content, err := parseResponse(responseBody)
	if err != nil {
		log.Printf("Error parsing response: %v. Raw response: %s", err, string(responseBody)) // Log the raw response for debugging
		return "Error occurred. Please check logs for details."                               // Return a user-friendly message
	}
	return content
}
